#+PROPERTY: header-args :session finite_bath_lamb :kernel julia-1.8 :pandoc yes :async yes

#+begin_src jupyter-julia
  using DrWatson
  using Revise
  using Plots
  using LinearAlgebra
  using Setfield
  @quickactivate "discrete_walk"

  Revise.includet(srcdir("WalkModel.jl"))
  using .WalkModel
  Revise.includet(srcdir("Utilities.jl"))
  using .Utilities
#+end_src

#+RESULTS:
: [32m[1m  Activating[22m[39m project at `~/Documents/org/roam/data/c4/5097d2-2599-426d-82db-6ecfb5207151`


#+begin_src jupyter-julia
  (full_prototype, prototype, spectral_density) = let
      v = 1
      u = 2
      J = .01
      Œ± = 0.5
      œâ_c = 1
      N = 100
      p = ExtendedModelParameters(v, u, 0, J, œâ_c, Œ±, N, LinearBathDiscretization, true, 0, true)

      p, ModelParameters(p), OhmicSpectralDensity(p)
  end
  prototype
#+end_src

#+RESULTS:
: ModelParameters
:   v: Int64 1
:   u: Int64 2
:   œâ: Int64 0
:   Œµ: Array{Float64}((100,)) [0.005, 0.015, 0.025, 0.035, 0.045, 0.055, 0.065, 0.075, 0.085, 0.095  ‚Ä¶  0.905, 0.915, 0.925, 0.935, 0.945, 0.955, 0.965, 0.975, 0.985, 0.995]
:   g: Array{Float64}((100,)) [0.00316227766016838, 0.004276011137434268, 0.004865927761445336, 0.005295136992839155, 0.005639450228079817, 0.005930091541620684, 0.006183300672580194, 0.0064087111188735795, 0.0066125509465186595, 0.006799100382906402  ‚Ä¶  0.011945587069691553, 0.011978450233698779, 0.012011045118058816, 0.012043376778098804, 0.01207545012104379, 0.012107269911870704, 0.012138840778872466, 0.012170167218950265, 0.0122012536026469, 0.012232104178940925]
:   sw_approximation: Bool true
: 

#+begin_src jupyter-julia
  function lamb_shift(params::ModelParameters)
      H = hamiltonian(0, params)
      œà_A = [1; zeros(num_bath_modes(params))]
      energies = eigvals(H)
      ev = eigvecs(H)
      overlaps = (œà_A' * ev .|> abs)'
      index = argmax(overlaps)

      isolated_energy = energies[index]
      mininum(abs(isolated_energy - energies))
  end
  relative_lamb_shift(sol::WalkSolution) = lamb_shift(sol) / minimum(abs.(sol.energies[begin + 2:end] - sol.energies[begin + 1:end-1]))
#+end_src

#+RESULTS:
: relative_lamb_shift (generic function with 1 method)

* Hunting for the Lamb Shift
Let's start with definitng our system.

Now we can diagonalize and plot the density of states.
#+begin_src jupyter-julia
  let
      sol = WalkSolution(0, prototype)
      histogram(sol.energies[begin+1:end], label="Continuum", bins=10)
      vline!(sol.energies[begin:begin + 1], linewidth=2, label="Isolated")
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/9fe95fd36adec21aea019dd3e7940b9d43c402c0.svg]]

We see a nice gap :).


Let's look at the eigenstates.
#+begin_src jupyter-julia
  let
      H = hamiltonian(0, prototype)
      œà_A = [1; zeros(num_bath_modes(prototype))]
      energies = eigvals(H)
      overlaps = (œà_A' * eigvecs(H) .|> abs)'
      bar(energies, overlaps, xlabel="E", ylabel="Overlap with A")
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/897b162e337766b1146830a361af6f82265db8c3.svg]]
Here we have one isolated state.


#+begin_src jupyter-julia
  let
      params = ModelParameters(@set full_prototype.J = 1)

      H = hamiltonian(0, params)
      œà_A = [1; zeros(num_bath_modes(prototype))]
      energies = eigvals(H)
      overlaps = (œà_A' * eigvecs(H) .|> abs)'
      bar(energies, overlaps, xlabel="E", ylabel="Overlap with A")
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/80d4151649e9e770aae1f832bc02561d7c3d35a9.svg]]
In the strong coupling regime we get two nicely separated states with
big A component.


* Systematics
Now let's plot the gap between the continuum and the isolated state as
a function of different parameters.

** k - Dependence
Let's look at the lamb shift as a function of `k`.
So up to scaling, it is the same! This is sensible, as this is the
only \(k\) dependence of the problem.
#+begin_src jupyter-julia
   begin
       plot(k -> WalkSolution(k, prototype) |> lamb_shift, 0, 2œÄ,
            label="lamb shift", xlabel="k")
       plot!(k -> abs2(v(k, prototype)) / 100, 0, 2œÄ, label="v(k)")
   end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/4bc3bcebc441ef9aacdb3c09f900e5f297c54cd8.svg]]


This also holds for stronger coupling.
#+begin_src jupyter-julia
    begin
        plot(k -> WalkSolution(k, @set prototype.g *= 10) |> lamb_shift, 0, 2œÄ,
             xlabel="k", label="lamb shift")
        plot!(k -> abs2(v(k, prototype)), 0, 2œÄ, label="v(k)")
    end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/cde810a8c1dd609cc05aa416b756609fa0b0e87e.svg]]


Or without the SW transform.
#+begin_src jupyter-julia
    begin
        plot(k -> WalkSolution(k, @set prototype.sw_approximation = false) |> lamb_shift, 0, 2œÄ,
             label="lamb shift", xlabel="k")
        plot!(k -> abs2(v(k, prototype) / 1), 0, 2œÄ, label="v(k)")
    end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/48221a93faf18b18d90711f11081bf294ed35174.svg]]

** Œ± - Dependence
We find a very minor dependence on Œ±.
#+begin_src jupyter-julia
  begin
      p = plot(ylabel="lamb shift (normalized)", xlabel="Œ±")
      local shift(Œ±, J_rel) = lamb_shift(WalkSolution(0, ModelParameters(setproperties(full_prototype, Œ±=Œ±, J=J_rel))))
      for J_rel in [1, 2]
          local norm = shift(0, J_rel)
          plot!(Œ± -> shift(Œ±, J_rel) / norm, 0, 4, label="J_rel = $(J_rel)")
      end
      p
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/96f444cf830c49bc1c9b2dbfe991c5c933b8940d.svg]]

With increasing coupling strength this dependence is more and more
sensitive, but it amounts to only a few percent.

** N - Dependence
#+begin_src jupyter-julia
  begin
      local Ns = collect(10:500)
      local shifts = [lamb_shift(WalkSolution(0, ModelParameters(@set full_prototype.N = N))) for N in Ns]
      plot(Ns, shifts / shifts[begin], ylabel="lamb shift", xlabel="N")
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/d53c3519ab96d7aa7948cce411ecae5dacc4ff48.svg]]

We see that we approach a limit, but the relative difference is not
too great. In fact, here it is sub percent. We shoudl be able to
obtain the lamb shift from the continuum limit.

** Coupling Strength - Dependence
If we plot the lamb shift relative to the miminal energy gap in the
continuum, we se a monotnous behavior.

Here I've ploted it on a log-log scale and we can tell, that the shift
follows a power law in coupling strength. It is basically proportional
to the coupling matrix elements which are proportional to the square root.
#+begin_src jupyter-julia
  let
      p = plot(xlabel="J", ylabel="lamb shift relative to minimum continuum spacing")
      solution(J_rel) = WalkSolution(0, ModelParameters(@set full_prototype.J = J_rel))
      shift(J_rel) = relative_lamb_shift(solution(J_rel))

      plot!(shift, 1e-8, 10, xscale=:log10, yscale=:log10, label="Lamb Shift")
      plot!(x->1000*sqrt(x), label="sqrt")

      p
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/844d0fc4511ae7b713bb8ae0794a3a5a489485f4.svg]]

In the limit of weak coupling the the lamb shift seems to reach a
constant value.

* Compensating the Lamb Shift
Aparrently it is not trivial to close the gap at finite cuping
strengths. Maybe I'm misidentifying the isolated level though.
#+begin_src jupyter-julia
  let
      p = plot(xlabel="Œµ shift", ylabel="relative lamb shift")
      solution(Œµ_shift, J_rel) = WalkSolution(0, ModelParameters(setproperties(full_prototype, Œµ_shift = Œµ_shift, J = J_rel)))
      shift(Œµ_shift, J_rel) = lamb_shift(solution(Œµ_shift, J_rel))

      for J_rel in [.1, 1e-2, 1e-3, 1e-4]
          norm = shift(0, J_rel)
          plot!(e -> shift(e, J_rel) / norm, -.5, .01, label="J_rel = $(J_rel)")
      end
      p
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/6372017e90b4ae7c7392995930c808f4653aee62.svg]]

So we can only (reasonably) remove the lamb shift for weak coupling.



#+begin_src jupyter-julia
  let
      p = plot(xlabel="Œµ shift", ylabel="relative lamb shift")
      solution(Œµ_shift, J_rel) = WalkSolution(0, ModelParameters(setproperties(full_prototype, Œµ_shift = Œµ_shift, J = J_rel, N=10)))
      shift(Œµ_shift, J_rel) = lamb_shift(solution(Œµ_shift, J_rel))

      for J_rel in [.1, 1e-2, 1e-3, 1e-4]
          norm = shift(0, J_rel)
          plot!(e -> shift(e, J_rel) / norm, -.5, .01, label="J_rel = $(J_rel)")
      end
      p
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/58f15c22e7438b005a8ad9972e53833f231b3864.svg]]

Interestingly, the optimal shift is dependent on the number of bath levels.

The spectrum corrected for the lamb shift looks like:
#+begin_src jupyter-julia
  let
      H = hamiltonian(0, ModelParameters(@set full_prototype.Œµ_shift = -.045))
      œà_A = [1; zeros(num_bath_modes(prototype))]
      energies = eigvals(H)
      overlaps = (œà_A' * eigvecs(H) .|> abs)'
      bar(energies, overlaps, xlabel="E", ylabel="Overlap with A")
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/ce7e1f50f8c404d287cb3ae661ca15058317ee75.svg]]

** Mean Displacement for Shifted Bath
This is \(œÅ_A\) and the mean displacement for the shifted bath.
#+begin_src jupyter-julia
  let
      params = @set full_prototype.Œµ_shift = -.045
      plot_overview(params, 100)
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/23a8d55c20ea3c4fe56101a33452e10503cdf252.svg]]

At first, this doesn't seem too helpful. Let's contrast it with the
behavior for the unshifted bath.
#+begin_src jupyter-julia
  let
      plot_overview(full_prototype, 100)
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/c3f765fb7da9ebb6e191c239db7d206a5e73cdfd.svg]]
That certainly is a difference.
