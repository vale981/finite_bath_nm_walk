#+PROPERTY: header-args :session finite_bath_lamb :kernel julia-1.8 :pandoc yes :async yes

#+begin_src jupyter-julia
  using DrWatson
  using Revise
  using Plots
  using LinearAlgebra
  using Accessors
  using Statistics
  @quickactivate "discrete_walk"

  Revise.includet(srcdir("WalkModel.jl"))
  using .WalkModel
  Revise.includet(srcdir("Utilities.jl"))
  using .Utilities
#+end_src

#+RESULTS:
: [32m[1m  Activating[22m[39m project at `~/Documents/org/roam/data/c4/5097d2-2599-426d-82db-6ecfb5207151`


#+begin_src jupyter-julia
  (full_prototype, prototype, spectral_density) = let
      v = 1
      u = 2
      J = .01
      Œ± = 0.5
      œâ_c = 1
      N = 100
      p = ExtendedModelParameters(v, u, 0, OhmicSpectralDensity(œâ_c, J, Œ±), N, LinearBathDiscretization, true, 0, true)

      p, ModelParameters(p), OhmicSpectralDensity(p)
  end
  prototype
#+end_src

#+RESULTS:
: ModelParameters
:   v: Int64 1
:   u: Int64 2
:   œâ: Int64 0
:   Œµ: Array{Float64}((100,)) [0.005, 0.015, 0.025, 0.035, 0.045, 0.055, 0.065, 0.075, 0.085, 0.095  ‚Ä¶  0.905, 0.915, 0.925, 0.935, 0.945, 0.955, 0.965, 0.975, 0.985, 0.995]
:   g: Array{Float64}((100,)) [0.00316227766016838, 0.004276011137434268, 0.004865927761445336, 0.005295136992839155, 0.005639450228079817, 0.005930091541620684, 0.006183300672580194, 0.0064087111188735795, 0.0066125509465186595, 0.006799100382906402  ‚Ä¶  0.011945587069691553, 0.011978450233698779, 0.012011045118058816, 0.012043376778098804, 0.01207545012104379, 0.012107269911870704, 0.012138840778872466, 0.012170167218950265, 0.0122012536026469, 0.012232104178940925]
:   sw_approximation: Bool true
: 

We rename this function, because of compatibility.
#+begin_src jupyter-julia
  relative_lamb_shift(args...) = lamb_shift(args..., true)
#+end_src

#+RESULTS:
: relative_lamb_shift (generic function with 1 method)

* Hunting for the Lamb Shift
:PROPERTIES:
:ID:       66063e28-0b0c-4635-89d4-6f7cf1cea4fa
:END:
Let's start with definitng our system.

Now we can diagonalize and plot the density of states.
#+begin_src jupyter-julia
  let
      sol = WalkSolution(0, prototype)
      print(lamb_shift(full_prototype))
      histogram(sol.energies[begin+1:end], label="Continuum", bins=10)
      vline!(sol.energies[begin:begin + 1], linewidth=2, label="Isolated")
  end
#+end_src

#+RESULTS:
:RESULTS:
: 0.04460516855585549
[[file:./.ob-jupyter/c60e75c877b13adb87934bb83a5ecab91030ec1c.svg]]
:END:

We see a nice gap :).


Let's look at the eigenstates.
#+begin_src jupyter-julia
  let
      H = hamiltonian(0, prototype)
      œà_A = [1; zeros(num_bath_modes(prototype))]
      energies = eigvals(H)
      overlaps = (œà_A' * eigvecs(H) .|> abs)'
      bar(energies, overlaps, xlabel="E", ylabel="Overlap with A")
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/a6cc1a34d7b7e5bef06b062e76aaed2c61b17dcf.svg]]
Here we have one isolated state.


#+begin_src jupyter-julia
  let
      params = ModelParameters(@set full_prototype.spectral_density.J = 1)

      H = hamiltonian(0, params)
      œà_A = [1; zeros(num_bath_modes(prototype))]
      energies = eigvals(H)
      overlaps = (œà_A' * eigvecs(H) .|> abs)'
      bar(energies, overlaps, xlabel="E", ylabel="Overlap with A")
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/275870ca8f9697b785659577000ea287654e86f9.svg]]
In the strong coupling regime we get two nicely separated states with
big A component.


* Systematics
:PROPERTIES:
:ID:       44311ab8-c780-4376-8dad-0c2f0d39b3b6
:END:
Now let's plot the gap between the continuum and the isolated state as
a function of different parameters.

** k - Dependence
Let's look at the lamb shift as a function of `k`.
So up to scaling, it is the same! This is sensible, as this is the
only \(k\) dependence of the problem.
#+begin_src jupyter-julia
   begin
       plot(k -> lamb_shift(full_prototype, k), 0, 2œÄ,
            label="lamb shift", xlabel="k")
       plot!(k -> abs2(v(k, prototype)) / 100, 0, 2œÄ, label="v(k)")
   end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/c404a4fc5a5e57269a50c9788d588c6d8c3d7754.svg]]


This also holds for stronger coupling.
#+begin_src jupyter-julia
  let
      params = @set full_prototype.spectral_density.J = .1
      plot(k -> lamb_shift(params, k), 0, 2œÄ, label="lamb shift", xlabel="k")
      plot!(k -> abs2(v(k, prototype))/10, 0, 2œÄ, label="v(k)")
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/3fde0e4f96fc2d6f8ab9f4239c4efd9de7c7f1ca.svg]]


Or without the SW transform.
#+begin_src jupyter-julia
    let
      params = @set full_prototype.sw_approximation = false
      plot(k -> lamb_shift(params, k), 0, 2œÄ, label="lamb shift", xlabel="k")
      plot!(k -> abs2(v(k, prototype))/10, 0, 2œÄ, label="v(k)")
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/980e229430a8c030da7d6a15ef2925221346486f.svg]]

** Œ± - Dependence
:PROPERTIES:
:ID:       2115fb4c-eed9-4ef2-94ee-43d67b68d2fd
:END:
We find a very minor dependence on Œ±.
#+begin_src jupyter-julia
  let
      p = plot(ylabel="lamb shift (normalized)", xlabel="Œ±")
      shift(Œ±, J_rel) = lamb_shift(@set full_prototype.spectral_density = setproperties(full_prototype.spectral_density, Œ±=Œ±, J=J_rel))
      for J_rel in [1, 2]
          local norm = shift(0, J_rel)
          plot!(Œ± -> shift(Œ±, J_rel) / norm, 0, 4, label="J_rel = $(J_rel)")
      end
      p
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/3baeae5132d04d5df9d96ad664fa99f21a83bcfc.svg]]

With increasing coupling strength this dependence is more and more
sensitive, but it amounts to only a few percent.

** N - Dependence
:PROPERTIES:
:ID:       ad37e92b-829a-4a1b-890e-3c07c330085a
:END:
#+begin_src jupyter-julia
  begin
      local Ns = collect(10:500)
      local shifts = [lamb_shift(@set full_prototype.N = N) for N in Ns]
      plot(Ns, shifts / shifts[begin], ylabel="lamb shift", xlabel="N")
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/369d10abfcf9497574d698e37e555929c6350928.svg]]

We see that we approach a limit, but the relative difference is not
too great. In fact, here it is sub percent. We shoudl be able to
obtain the lamb shift from the continuum limit.

** Coupling Strength - Dependence
:PROPERTIES:
:ID:       20f068be-c8c2-4d7e-991b-96f0d58224a9
:END:
If we plot the lamb shift relative to the miminal energy gap in the
continuum, we se a monotnous behavior.

Here I've ploted it on a log-log scale and we can tell, that the shift
follows a power law in coupling strength. It is basically proportional
to the coupling matrix elements which are proportional to the square root.
#+begin_src jupyter-julia
  let
      p = plot(xlabel="J", ylabel="lamb shift relative to minimum continuum spacing")
      shift(J_rel) = relative_lamb_shift(@set full_prototype.spectral_density.J = J_rel)

      plot!(shift, 1e-8, 10, xscale=:log10, yscale=:log10, label="Lamb Shift")
      plot!(x->1000*sqrt(x), label="sqrt")

      p
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/d6216cba4f2bb9cac1df310319b780c9f0800fcd.svg]]

In the limit of weak coupling the the lamb shift seems to reach a
constant value.

* Compensating the Lamb Shift
:PROPERTIES:
:ID:       120a110c-00a8-480f-960d-3ea1900ed94e
:END:
Aparrently it is not trivial to close the gap at finite cuping
strengths. Maybe I'm misidentifying the isolated level though.
#+begin_src jupyter-julia
  let
      p = plot(xlabel="Œµ shift", ylabel="relative lamb shift")
      solution(Œµ_shift, J_rel) = WalkSolution(0, ModelParameters(setproperties(full_prototype, Œµ_shift = Œµ_shift, J = J_rel)))
      function shift(Œµ_shift, J_rel)
          params = @set full_prototype.Œµ_shift = Œµ_shift
          @reset params.spectral_density.J = J_rel
          lamb_shift(params)
      end

      for J_rel in [.1, 1e-2, 1e-3, 1e-4]
          norm = shift(0, J_rel)
          plot!(e -> shift(e, J_rel) / norm, -.1, .01, label="J_rel = $(J_rel)")
      end
      p
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/63b47d0418a456172656ab02a5e94faad8c78b11.svg]]

We can see that the index of the A-dominant level changes. Further,
there is a minimum in the relative change that can be achieved.
Only in the weak-ish coupling limit we can make the gap close by a
small shift.

#+begin_src jupyter-julia
  let
      p = plot(xlabel="Œµ shift", ylabel="relative lamb shift")
      solution(Œµ_shift, J_rel) = WalkSolution(0, ModelParameters(setproperties(full_prototype, Œµ_shift = Œµ_shift, J = J_rel)))
      function shift(Œµ_shift, J_rel)
          params = @set full_prototype.Œµ_shift = Œµ_shift
          @reset params.spectral_density.J = J_rel
          @reset params.N = 10
          lamb_shift(params)
      end

      for J_rel in [.1, 1e-2, 1e-3, 1e-4]
          norm = shift(0, J_rel)
          plot!(e -> Shift(e, J_rel) / norm, -.5, .01, label="J_rel = $(J_rel)")
      end
      p
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/a4eb0070c0ea73bef702111aa30267067dafb1b0.svg]]

Interestingly, the optimal shift is dependent on the number of bath levels.

The spectrum corrected for the lamb shift looks like:
#+begin_src jupyter-julia
  let
      H = hamiltonian(0, ModelParameters(@set full_prototype.Œµ_shift = -.058))
      @show full_prototype.spectral_density.J
      œà_A = [1; zeros(num_bath_modes(prototype))]
      energies = eigvals(H)
      overlaps = (œà_A' * eigvecs(H) .|> abs)'
      bar(energies, overlaps, xlabel="E", ylabel="Overlap with A")
  end
#+end_src

#+RESULTS:
:RESULTS:
: full_prototype.spectral_density.J = 0.01
[[file:./.ob-jupyter/e3de4514b08f58d93e74a2a90e55a8e93c931349.svg]]
:END:
So there is certainly an attraction and a change in the DOS.

#+begin_src jupyter-julia
  let
      H = hamiltonian(0, ModelParameters(@set full_prototype.Œµ_shift = -.058))
      @show full_prototype.spectral_density.J
      œà_A = [1; zeros(num_bath_modes(prototype))]
      energies = eigvals(H)
      overlaps = (œà_A' * eigvecs(H) .|> abs)'
      bar(energies, overlaps, xlabel="E", ylabel="Overlap with A")
  end
#+end_src


** Mean Displacement for Shifted Bath
:PROPERTIES:
:ID:       6d3a3b71-5fc7-4c19-a574-c6a735f642fa
:END:
This is \(œÅ_A\) and the mean displacement for the shifted bath.
#+begin_src jupyter-julia
  let
      params = @set full_prototype.Œµ_shift = -.058
      plot_overview(params, 1000)
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/41438e553e75f1c291cd196fec912a64a21d6707.svg]]
**Nice, with this choice we get revivals, so a proper choice of time
scale is crucial!** Also, the average should be taken more locally
around the time. We see that the displacement converges on \(1\).

At first, this doesn't seem too helpful. Let's contrast it with the
behavior for the unshifted bath.
#+begin_src jupyter-julia
  let
      plot_overview(full_prototype, 1000)
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/d9945c1c006fa6484b79fa5f69f8f1709b2b1416.svg]]
That certainly is a difference. **Revivals still happen at the same time**

And for \(u<1\).

#+begin_src jupyter-julia
  let
      params = @set full_prototype.Œµ_shift = -.058
      @reset params.u = .5
      H = hamiltonian(0, ModelParameters(params))
      œà_A = [1; zeros(num_bath_modes(prototype))]
      energies = eigvals(H)
      overlaps = (œà_A' * eigvecs(H) .|> abs)'
      bar(energies, overlaps, xlabel="E", ylabel="Overlap with A")
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/32b6923a88aa76278b096135b9d1e2241f839cfa.svg]]

#+begin_src jupyter-julia
  let
      params = @set full_prototype.Œµ_shift = -.052
      @reset params.u = .5
      plot_overview(params, 1000)
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/9b4528d765988f4e799b38e50bb3e3e50c4a8bf0.svg]]
Nice, we converge to \(0\) just before the revival.


** Superohmic SD
:PROPERTIES:
:ID:       91ae3bdf-560d-4bf7-8658-6e129bf5ff48
:END:
Now, how does this play out in the super-ohmic case?
#+begin_src jupyter-julia
  let
      params = @set full_prototype.Œµ_shift = -.035
      @reset params.spectral_density.Œ± = 1.5
      @reset params.u = .5
      H = hamiltonian(0, ModelParameters(params))
      œà_A = [1; zeros(num_bath_modes(prototype))]
      energies = eigvals(H)
      overlaps = (œà_A' * eigvecs(H) .|> abs)'
      bar(energies, overlaps, xlabel="E", ylabel="Overlap with A")
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/47fe2f16445c3cca0d7515e64c3d3c0f4ca729b4.svg]]
We see that the modification of the other levels is way smaller ->
this is likely because the coupling relative to the energy gap does
not converge. Still, we're able to close the gap :).


#+begin_src jupyter-julia
  let
      params = @set full_prototype.Œµ_shift = -.035
      @reset params.spectral_density.Œ± = 1.5
      @reset params.u = 2
      plot_overview(params, 1500)
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/0c432981d3a1a3537c8ab553bc5a275a10e6d879.svg]]
Revival time seems stable-ish. And the mean displacement is now
different from one. Interestingly the behavior after the revival
change s kind of drastically. 

* Revivals
:PROPERTIES:
:ID:       42d77362-4821-4c83-b55e-630eb7e8f17e
:END:
Does \(œÅ_A\) revival look similar for other \(k\)? (most likely)
#+begin_src jupyter-julia
  let
      params = @set full_prototype.Œµ_shift = -.035
      @reset params.spectral_density.Œ± = 1.5
      @reset params.u = 2
      p = plot(xlabel="t", ylabel=raw"$\rho_A$")
      for k in LinRange(0, œÄ, 5)
          sol = WalkSolution(k, ModelParameters(params))
          plot!(t->a_weight(t, sol), 0, 1500, label="k=$(round(k, sigdigits=2))")
      end
      p
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/a705ee22117f799a9853141732db9faef9a1ed82.svg]]

If we go back to the original 
#+begin_src jupyter-julia
  let
      params = full_prototype
      p = plot(xlabel="t", ylabel=raw"$\rho_A$")
      for k in LinRange(0, œÄ, 5)
          sol = WalkSolution(k, ModelParameters(params))
          plot!(t->a_weight(t, sol), 0, 1500, label="k=$(round(k, sigdigits=2))")
      end
      p
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/98c5d619f237715249e6ce12b2d6829cf127e453.svg]]

Nice, the revival time is just ~2œÄ * number of levels~ as we inherit
the structure of the bath.

** Exponential Spacing
:PROPERTIES:
:ID:       8bd2cabc-eb99-46ed-8644-9bcfa0eccc54
:END:
What happens if we choose the exponential spacing?
#+begin_src jupyter-julia
  let
        p = plot(xlabel="t", ylabel=raw"$\rho_A$")
        for k in LinRange(0, œÄ, 2)
            for d in [LinearBathDiscretization, ExponentialBathDiscretization]
                params = @set full_prototype.discretization = d
                @reset params.Œµ_shift = -.058

                sol = WalkSolution(k, ModelParameters(params))
                plot!(t->a_weight(t, sol), 0, 1500, label="k=$(round(k, sigdigits=2)), $(discretization_name(d))")
            end
        end
        p
    end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/79f6c15d659345214b753772b3c359a32b57b643.svg]]
Now stuff is way less smooth and doesn't experience revivals. It also
seems to fix the weird behavior before revival.


How does this pan out mean-displacement wise?
#+begin_src jupyter-julia
  let
      params = @set full_prototype.Œµ_shift = -.058
      @reset params.discretization = ExponentialBathDiscretization
      plot_overview(params, 1500)
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/abebfd0faf5bf30f1e8c423a170e7b8e9100a563.svg]]
The revival is pushed far without changing the behavior much. But it
adds noise... We see that the infinite time average can't be trusted!

On the flipside \(\ev{m}\) approaches \(1\) way closer as in the
linear case.
#+begin_src jupyter-julia
  let
      params = @set full_prototype.Œµ_shift = -.058
      @reset params.discretization = ExponentialBathDiscretization
      @reset params.N = 50
      plot_overview(params, 1500)
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/a132d9d76528b740487fd99de546e38203efabd1.svg]]
Even 50 modes works well. And we see the revival.



Can we predict the revival time?
#+begin_src jupyter-julia
  let
      p = plot(xlabel="t", ylabel=raw"$\rho_A$")
      k = 0
      params = @set full_prototype.discretization = ExponentialBathDiscretization
      @reset params.Œµ_shift = -.058
      @reset params.N = 100

      sol = WalkSolution(k, ModelParameters(params))
      plot!(t->a_weight(t, sol), 0, 5000, label="k=$(round(k, sigdigits=2))")
      Œµ, _ = discretize_bath(params)
      vline!([2œÄ/(median(Œµ[begin+1:end] - Œµ[begin:end-1]))], label="median")
      vline!([2œÄ/(minimum(Œµ[begin+1:end] - Œµ[begin:end-1]))], label="minimum")
      p
    end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/edc060953ea381725b72781d44dbf1d43cf32058.svg]]
Seems to be harder. But sometwhere between the median and the minimum
seems good.

* Automating the Shifting
Generically, we have to shift the bath to lower energies to close the
gap in the spectrum.

We can do this numerically, by minizmizing the distance between the
first level and all the others. We can minimize the absolute value of
the lamb shift shown in [[id:120a110c-00a8-480f-960d-3ea1900ed94e][Compensating the Lamb Shift]].

We begin by reproducing the result from [[id:120a110c-00a8-480f-960d-3ea1900ed94e][above]] for the standard
configuration chosen at the top of the notebook.

By a simple binary search, we can find the point where the shift
switches sign. The binary search finds upper and lower bounds for the
transition and we take the upper bound.
#+begin_src jupyter-julia
  let
      p = plot(xlabel="Œµ shift", ylabel="relative lamb shift", ylim=(-1, 1))
      solution(Œµ_shift, J_rel) = WalkSolution(0, ModelParameters(setproperties(full_prototype, Œµ_shift = Œµ_shift, J = J_rel)))
      function shift(Œµ_shift)
          params = @set full_prototype.Œµ_shift = Œµ_shift
          lamb_shift(params)
      end

      vline!([optimal_bath_shift(full_prototype, 0.)])

      norm = shift(0)
      plot!(e -> (shift(e))/norm, -.07, -.05)
      p
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/1a44f28a752718a719e372d81a3210db0d5e8788.svg]]

Let's try this for multiple couping strengths.
#+begin_src jupyter-julia
  let
      p = plot(xlabel="Œµ shift", ylabel="relative lamb shift")
      function shifted_params(Œµ_shift, J_rel)
          params = @set full_prototype.Œµ_shift = Œµ_shift
          @reset params.spectral_density.J = J_rel
          @reset params.N = 10
      end

      shift(Œµ_shift, J_rel) = lamb_shift(shifted_params(Œµ_shift, J_rel))

      for (c, J_rel) in enumerate([.1, 1e-2, 1e-3, 1e-4])
          norm = shift(0, J_rel)
          plot!(e -> shift(e, J_rel) / norm, -.5, .01, label="J_rel = $(J_rel)", color=c)
          vline!([optimal_bath_shift(shifted_params(0, J_rel), 0)], color=c, linestyle=:dash, label=false)
      end
      p
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/679e6a401188771a6099485e2b0ceefa429db186.svg]]

Nice! All the shifts are detected correctly.
How does it look like for different \(Œ±\)?

#+begin_src jupyter-julia
  let
      p = plot(xlabel="Œµ shift", ylabel="relative lamb shift")
      function shifted_params(Œµ_shift, Œ±)
          params = @set full_prototype.Œµ_shift = Œµ_shift
          @reset params.spectral_density.Œ± = Œ±
          @reset params.N = 10
      end

      shift(Œµ_shift, Œ±) = lamb_shift(shifted_params(Œµ_shift, Œ±))

      for (c, Œ±) in enumerate(LinRange(0, 2, 5))
          norm = shift(0, Œ±)
          plot!(e -> shift(e, Œ±) / norm, -.15, .01, label="Œ± = $(Œ±)", color=c)
          vline!([optimal_bath_shift(shifted_params(0, Œ±), 0)], color=c, linestyle=:dash, label=false)
      end
      p
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/c617a6c6db0fff81fd3f4aca409eb27f6d4dab69.svg]]
Interestingly, the shift dependence on \(Œ±\) is non-trivial.
#+begin_src jupyter-julia
  let
      shift(Œ±) = optimal_bath_shift((@set full_prototype.spectral_density.Œ± = Œ±) |> ModelParameters, 0)
      plot(shift, 0.01, 2, xlabel="Œ±", ylabel="bath shift")
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/e2894f609af226248de8f463f9b75f21335c99f9.svg]]
#+begin_src jupyter-julia
  let
      baseline = optimal_bath_shift(full_prototype, 0)
      baseline_shift = lamb_shift((@set full_prototype.Œµ_shift = optimal_bath_shift(full_prototype, 0)), 0)

      plot(k -> optimal_bath_shift(full_prototype, k) / baseline, 0, 2œÄ, xlabel="k", label="energy shift")
      plot!(k -> lamb_shift((@set full_prototype.Œµ_shift = optimal_bath_shift(full_prototype, k)), k) / baseline_shift, label="lamb shift (optimized)")
      plot!(k -> lamb_shift((@set full_prototype.Œµ_shift = baseline), k) / baseline_shift, label="lamb shift")
  end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/4a019bd71f696898531aadb8d37fe6cd1bb73352.svg]]

The \(k\) dependence might be a problem, as it is quite
significant. As we see, the energy gap (lamb shift) also varies
significantly. Even worse, the green curve shows, that the shift at
\(k=0\) just doesn't work for other values of \(k\).

We will see below however, that this overcompensation still produces
OK results.

** Phase Diagram with "Overcompensation"
:PROPERTIES:
:ID:       f0b8a81b-3996-430c-b7d9-b2e6beb58586
:END:
With this we can attempt to generate the phase diagram.
#+begin_src jupyter-julia
  let
      params = full_prototype
      plot_phase_diagram((@set params.N = 300), 8)
  end

#+end_src

#+RESULTS:
:RESULTS:
: maximum(displacement) = 0.9997545417297065
[[file:./.ob-jupyter/dd722a07d2755fd321d5e47ab18be30bb7ec2ad4.svg]]
:END:

Or with weaker coupling.
#+begin_src jupyter-julia
  let
      params = @set full_prototype.spectral_density.J = .001
      plot_phase_diagram((@set params.N = 300), 8)
  end

#+end_src

#+RESULTS:
:RESULTS:
: maximum(displacement) = 0.9654184835226091
[[file:./.ob-jupyter/d81b69c1a7778960897e62181707c6894d3c9e70.svg]]
:END:

Or stronger.
#+begin_src jupyter-julia
  let
      params = @set full_prototype.spectral_density.J = .02
      plot_phase_diagram((@set params.N = 300), 8)
  end
#+end_src

#+RESULTS:
:RESULTS:
: maximum(displacement) = 0.999976876133196
[[file:./.ob-jupyter/a0fbcea823cd4bc96a5a550332e3b52a2f1887eb.svg]]
:END:

Ok there is a tradeof between coupling too strong and "destroying" the
phase transition. For weaker coupling, reaching the steady state takes
longer than the revival time. For stronger coupling, we destroy the
phase transtition, as the lamb shift can't be compensated.

** Phase Diagram with "Undercompensation"
We now explore what happens, if we choose to shift by the smalles
amount possible.

#+begin_src jupyter-julia
  let
      plot_phase_diagram((@set full_prototype.N = 300), 8, shift_k=œÄ)
  end
#+end_src

#+RESULTS:
:RESULTS:
: maximum(displacement) = 0.6688946754010082
[[file:./.ob-jupyter/482de872a1a44ee6e152e481286a06ce2a1aaadb.svg]]
:END:

The results are /worse/ compared to [[id:f0b8a81b-3996-430c-b7d9-b2e6beb58586][Phase Diagram with
"Overcompensation"]]. The maximum mean displacement is nowhere near
\(1\) and the transition is much less sharp.

** Behavior around the Critical \(Œ±\)
The phase transtion around \(Œ±= 1\) suffers from finite-size
effects. Let's explore their origin.

#+begin_src jupyter-julia
  let
      params = @set full_prototype.Œµ_shift = -.058
      @reset params.discretization = ExponentialBathDiscretization
      plot_overview(params, 1500)
  end
#+end_src
